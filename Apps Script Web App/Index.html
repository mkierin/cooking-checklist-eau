<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <base target="_top">
    <title>Cooking Checklist</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            table-layout: fixed;
        }
        
        th {
            background-color: #5b6abf;
            color: white;
            text-align: left;
            padding: 15px;
            font-size: 20px;
            position: sticky;
            top: 0;
        }
        
        td {
            padding: 15px;
            border-bottom: 1px solid #f0f0f0;
            font-size: 18px;
            height: 40px;
        }
        
        /* Alternating row colors */
        tr:nth-child(odd) {
            background-color: white;
        }
        
        tr:nth-child(even) {
            background-color: #f2f2f2;
        }
        
        /* Green background for rows with first checkbox checked */
        tr.cooked {
            background-color: #00ff9d !important;
        }
        
        /* Blue background for rows with second checkbox checked */
        tr.portioned {
            background-color: #99ccff !important;
        }
        
        /* Checkbox styling */
        input[type="checkbox"] {
            width: 30px;
            height: 30px;
            cursor: pointer;
        }
        
        /* First column (dish name) styling */
        td:first-child a {
            color: #0066cc;
            text-decoration: none;
            font-weight: bold;
            font-size: 18px;
            cursor: pointer;
        }
        
        td:first-child a:hover {
            text-decoration: underline;
        }
        
        /* Row number column */
        .row-number {
            width: 30px;
            text-align: center;
            background-color: #e0e0e0;
            color: #333;
            font-weight: bold;
        }
        
        /* Header row */
        .header-row {
            height: 40px;
        }
        
        /* Portion column */
        .portion-column {
            text-align: right;
            padding-right: 20px;
        }
        
        /* Animation for row movement */
        .animated-row {
            transition: all 0.5s ease-in-out;
        }
        
        /* Animation classes */
        .slide-up {
            animation: slideUp 0.5s ease-in-out;
        }
        
        .slide-down {
            animation: slideDown 0.5s ease-in-out;
        }
        
        @keyframes slideUp {
            from { transform: translateY(50px); opacity: 0.5; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        @keyframes slideDown {
            from { transform: translateY(-50px); opacity: 0.5; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        /* Loading spinner */
        .loader {
            border: 8px solid #f3f3f3;
            border-top: 8px solid #3498db;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 2s linear infinite;
            margin: 20px auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .loading-message {
            text-align: center;
            font-size: 18px;
            margin-top: 20px;
        }
        
        /* Status message */
        #status-message {
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            display: none;
        }
        
        .success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
    </style>
</head>
<body>
    <div id="app">
        <div id="status-message"></div>
        <div id="loading" style="display: none;">
            <div class="loader"></div>
            <div class="loading-message">Loading data from Google Sheets...</div>
        </div>
        <table id="cooking-checklist">
            <thead>
                <tr class="header-row">
                    <th class="row-number">#</th>
                    <th>Dish</th>
                    <th class="portion-column">Portions</th>
                    <th style="text-align: center;">Cooked</th>
                    <th style="text-align: center;">Portioned</th>
                </tr>
            </thead>
            <tbody id="table-body">
                <!-- Table rows will be generated dynamically -->
            </tbody>
        </table>
    </div>

    <script>
        // Initialize empty table data array that will be filled from Google Sheets
        // Format: [name, portions, checked1, checked2, url]
        const tableData = [];
        
        // Store original positions separately from the data
        const originalPositions = {};
        const rowIds = {};
        
        // Show loading indicator
        function showLoading() {
            document.getElementById('loading').style.display = 'block';
        }
        
        // Hide loading indicator
        function hideLoading() {
            document.getElementById('loading').style.display = 'none';
        }
        
        // Show status message
        function showStatusMessage(message, isError = false) {
            const statusElement = document.getElementById('status-message');
            statusElement.textContent = message;
            statusElement.className = isError ? 'error' : 'success';
            statusElement.style.display = 'block';
            
            // Hide after 5 seconds
            setTimeout(() => {
                statusElement.style.display = 'none';
            }, 5000);
        }
        
        // Function to fetch data from Google Sheets via Apps Script
        function fetchDataFromGoogleSheets() {
            showLoading();
            
            // Call the server-side function to get data
            google.script.run
                .withSuccessHandler(function(data) {
                    hideLoading();
                    
                    if (!data || data.length === 0) {
                        showStatusMessage('No data found in the spreadsheet', true);
                        initTable(); // Initialize with empty data
                        return;
                    }
                    
                    console.log('Retrieved data from Google Sheets:', data);
                    
                    // Clear the existing tableData array and replace with the new data
                    tableData.length = 0;
                    data.forEach(row => tableData.push(row));
                    
                    console.log('Table data updated, length:', tableData.length);
                    
                    // Reset position tracking since we have new data
                    resetPositionTracking();
                    
                    // Initialize the table with the new data
                    initTable();
                    
                    showStatusMessage('Data loaded successfully!');
                })
                .withFailureHandler(function(error) {
                    hideLoading();
                    console.error('Error fetching data:', error);
                    showStatusMessage('Failed to load data: ' + error, true);
                    
                    // Initialize with empty data if fetch fails
                    initTable();
                })
                .getTableData();
        }
        
        // Reset position tracking (used when loading new data)
        function resetPositionTracking() {
            // Clear existing position data
            Object.keys(originalPositions).forEach(key => delete originalPositions[key]);
            Object.keys(rowIds).forEach(key => delete rowIds[key]);
            console.log('Position tracking reset');
        }
        
        // Initialize or ensure original positions are tracked
        function initializePositionTracking() {
            // Generate a unique ID for each row based on its name (or other unique property)
            tableData.forEach((rowData, index) => {
                // Use dish name as a unique identifier
                const dishName = rowData[0];
                
                // If this dish doesn't have an ID yet, create one
                if (!rowIds[dishName]) {
                    rowIds[dishName] = Date.now() + index; // Unique ID
                }
                
                // If this dish doesn't have a position yet, store its current position
                if (originalPositions[dishName] === undefined) {
                    originalPositions[dishName] = index;
                }
            });
            
            console.log('Position tracking initialized:', originalPositions);
        }
        
        // Initialize the table
        function initTable() {
            const tableBody = document.getElementById('table-body');
            tableBody.innerHTML = '';
            
            // Make sure position tracking is initialized
            initializePositionTracking();
            
            console.log('Current original positions:', originalPositions);

            tableData.forEach((rowData, index) => {
                // Create row
                const row = createTableRow(rowData, index);
                
                // Add animation class
                row.classList.add('animated-row');
                
                // Add slide animation for newly moved rows
                if (rowData.isMoving) {
                    if (rowData.moveDirection === 'up') {
                        row.classList.add('slide-up');
                    } else if (rowData.moveDirection === 'down') {
                        row.classList.add('slide-down');
                    }
                    
                    // Clear the moving flag after animation
                    setTimeout(() => {
                        rowData.isMoving = false;
                        rowData.moveDirection = null;
                    }, 500);
                }
                
                tableBody.appendChild(row);
            });
        }

        // Create a table row
        function createTableRow(rowData, index) {
            const [dish, portions, cooked, portioned] = rowData;
            const row = document.createElement('tr');
            
            // Add row number cell
            const rowNumberCell = document.createElement('td');
            rowNumberCell.className = 'row-number';
            rowNumberCell.textContent = index + 1;
            row.appendChild(rowNumberCell);
            
            // Add dish name cell with hyperlink styling
            const dishCell = document.createElement('td');
            if (dish) {
                const dishLink = document.createElement('a');
                dishLink.href = rowData[4] || '#'; // Use URL from data or default to #
                dishLink.textContent = dish;
                dishLink.onclick = (e) => {
                    e.preventDefault();
                    alert('Clicked on: ' + dish);
                };
                dishCell.appendChild(dishLink);
            }
            row.appendChild(dishCell);
            
            // Add portions cell
            const portionsCell = document.createElement('td');
            portionsCell.className = 'portion-column';
            portionsCell.textContent = portions;
            row.appendChild(portionsCell);
            
            // Add cooked checkbox cell
            const cookedCell = document.createElement('td');
            cookedCell.style.textAlign = 'center';
            const cookedCheckbox = document.createElement('input');
            cookedCheckbox.type = 'checkbox';
            cookedCheckbox.checked = cooked;
            cookedCheckbox.addEventListener('change', function() {
                handleCheckboxChange(index, 2, this.checked);
            });
            cookedCell.appendChild(cookedCheckbox);
            row.appendChild(cookedCell);
            
            // Add portioned checkbox cell
            const portionedCell = document.createElement('td');
            portionedCell.style.textAlign = 'center';
            const portionedCheckbox = document.createElement('input');
            portionedCheckbox.type = 'checkbox';
            portionedCheckbox.checked = portioned;
            portionedCheckbox.addEventListener('change', function() {
                handleCheckboxChange(index, 3, this.checked);
            });
            portionedCell.appendChild(portionedCheckbox);
            row.appendChild(portionedCell);
            
            // Apply green background if cooked checkbox is checked
            if (cooked) {
                row.classList.add('cooked');
            }
            
            // Apply blue background if portioned checkbox is checked
            if (portioned) {
                row.classList.add('portioned');
            }
            
            return row;
        }

        // Handle checkbox change
        function handleCheckboxChange(rowIndex, columnIndex, isChecked) {
            // Get the dish name before updating the data (for logging)
            const dishName = tableData[rowIndex][0];
            console.log(`Checkbox change: ${dishName}, column ${columnIndex}, checked: ${isChecked}`);
            console.log(`Original position for ${dishName}: ${originalPositions[dishName]}`);
            
            // Update the data
            tableData[rowIndex][columnIndex] = isChecked;
            
            // Optionally save the checkbox state back to the spreadsheet
            saveCheckboxStateToSheet(dishName, columnIndex, isChecked);
            
            // Handle differently based on whether checking or unchecking
            if (isChecked) {
                // CHECKING: Show checkbox state and color change immediately
                initTable();
                
                // Add a delay before moving the row
                setTimeout(() => {
                    // If it's the "cooked" checkbox (column index 2)
                    if (columnIndex === 2) {
                        console.log(`Moving ${dishName} to top`);
                        // Move to top
                        moveRowToTop(rowIndex);
                    }
                    
                    // If it's the "portioned" checkbox (column index 3)
                    if (columnIndex === 3) {
                        console.log(`Moving ${dishName} to bottom`);
                        // Move to bottom
                        moveRowToBottom(rowIndex);
                    }
                    
                    // Refresh the table again to show the movement
                    initTable();
                }, 500); // 500ms delay before moving
            } else {
                // UNCHECKING: Move back immediately without animation
                // If it's the "cooked" checkbox (column index 2)
                if (columnIndex === 2) {
                    console.log(`Moving ${dishName} back to original position ${originalPositions[dishName]}`);
                    // Move back to original position immediately
                    moveRowToOriginalPosition(rowIndex, false); // false = no animation
                }
                
                // If it's the "portioned" checkbox (column index 3)
                if (columnIndex === 3) {
                    console.log(`Moving ${dishName} back to original position ${originalPositions[dishName]}`);
                    // Move back to original position immediately
                    moveRowToOriginalPosition(rowIndex, false); // false = no animation
                }
                
                // Refresh the table immediately
                initTable();
            }
        }
        
        // Save checkbox state to the spreadsheet (optional)
        function saveCheckboxStateToSheet(dishName, columnIndex, isChecked) {
            // Call the server-side function to save the state
            google.script.run
                .withSuccessHandler(function(success) {
                    if (success) {
                        console.log(`Successfully saved ${dishName} checkbox state to spreadsheet`);
                    } else {
                        console.error(`Failed to save ${dishName} checkbox state to spreadsheet`);
                    }
                })
                .withFailureHandler(function(error) {
                    console.error('Error saving checkbox state:', error);
                })
                .saveCheckboxState(dishName, columnIndex, isChecked);
        }

        // Move a row below other checked rows
        function moveRowToTop(rowIndex) {
            // Get the row data
            const rowData = tableData[rowIndex];
            
            // Add animation flags
            rowData.isMoving = true;
            rowData.moveDirection = 'up';
            
            // Remove the row from its current position
            tableData.splice(rowIndex, 1);
            
            // Find the position of the last checked row
            let insertPosition = 0; // Default to top position
            
            // Loop through the data to find the last checked row
            for (let i = 0; i < tableData.length; i++) {
                if (tableData[i][2] === true) { // If the row is checked (column 3)
                    insertPosition = i + 1; // Insert after this row
                }
            }
            
            // Insert the row at the determined position
            tableData.splice(insertPosition, 0, rowData);
            
            console.log(`Moved row to position ${insertPosition} (below other checked rows)`);
        }

        // Move a row to the bottom of the table
        function moveRowToBottom(rowIndex) {
            // Get the row data
            const rowData = tableData[rowIndex];
            
            // Add animation flags
            rowData.isMoving = true;
            rowData.moveDirection = 'down';
            
            // Remove the row from its current position
            tableData.splice(rowIndex, 1);
            
            // Add it to the end of the array
            tableData.push(rowData);
        }

        // Move a row back to its original position
        function moveRowToOriginalPosition(rowIndex, animate = true) {
            // Get the row data
            const rowData = tableData[rowIndex];
            
            // Get the dish name to look up the original position
            const dishName = rowData[0];
            
            // Get the original position from our mapping
            const originalIndex = originalPositions[dishName];
            
            console.log(`Moving row ${rowIndex} (${dishName}) back to original position ${originalIndex}`);
            
            // Add animation flags only if animation is requested
            if (animate) {
                rowData.isMoving = true;
                rowData.moveDirection = 'down';
            } else {
                // Make sure no animation happens
                rowData.isMoving = false;
                rowData.moveDirection = null;
            }
            
            // Remove the row from its current position
            tableData.splice(rowIndex, 1);
            
            // Make sure we don't insert beyond the array bounds
            const insertPosition = Math.min(originalIndex, tableData.length);
            
            // Insert it at the original position
            tableData.splice(insertPosition, 0, rowData);
            
            console.log(`Moved row back to position ${insertPosition}`);
        }

        // Remove duplicate dishes
        function removeDuplicates() {
            const uniqueDishes = new Set();
            const indicesToRemove = [];
            
            tableData.forEach((rowData, index) => {
                const dish = rowData[0];
                if (dish && uniqueDishes.has(dish)) {
                    indicesToRemove.push(index);
                } else if (dish) {
                    uniqueDishes.add(dish);
                }
            });
            
            // Remove duplicates from the end to avoid index shifting
            for (let i = indicesToRemove.length - 1; i >= 0; i--) {
                tableData.splice(indicesToRemove[i], 1);
            }
        }

        // Initialize the table when the page loads
        google.script.url.getLocation(function(location) {
            // Fetch data from Google Sheets and initialize the table
            fetchDataFromGoogleSheets();
        });
    </script>
</body>
</html>
