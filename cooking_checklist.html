<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cooking Checklist</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            table-layout: fixed;
        }
        
        th {
            background-color: #5b6abf;
            color: white;
            text-align: left;
            padding: 15px;
            font-size: 20px;
            position: sticky;
            top: 0;
        }
        
        td {
            padding: 15px;
            border-bottom: 1px solid #f0f0f0;
            font-size: 18px;
            height: 40px;
        }
        
        /* Alternating row colors */
        tr:nth-child(odd) {
            background-color: white;
        }
        
        tr:nth-child(even) {
            background-color: #f2f2f2;
        }
        
        /* Green background for rows with first checkbox checked */
        tr.cooked {
            background-color: #00ff9d !important;
        }
        
        /* Blue background for rows with second checkbox checked */
        tr.portioned {
            background-color: #99ccff !important;
        }
        
        /* Checkbox styling */
        input[type="checkbox"] {
            width: 30px;
            height: 30px;
            cursor: pointer;
        }
        
        /* First column (dish name) styling */
        td:first-child a {
            color: #0066cc;
            text-decoration: none;
            font-weight: bold;
            font-size: 18px;
            cursor: pointer;
        }
        
        td:first-child a:hover {
            text-decoration: underline;
        }
        
        /* Row number column */
        .row-number {
            width: 30px;
            text-align: center;
            background-color: #e0e0e0;
            color: #333;
            font-weight: bold;
        }
        
        /* Header row */
        .header-row {
            height: 40px;
        }
        
        /* Portion column */
        .portion-column {
            text-align: right;
            padding-right: 20px;
        }
        
        /* Animation for row movement */
        .animated-row {
            transition: all 0.5s ease-in-out;
        }
        
        /* Animation classes */
        .slide-up {
            animation: slideUp 0.5s ease-in-out;
        }
        
        .slide-down {
            animation: slideDown 0.5s ease-in-out;
        }
        
        @keyframes slideUp {
            from { transform: translateY(50px); opacity: 0.5; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        @keyframes slideDown {
            from { transform: translateY(-50px); opacity: 0.5; }
            to { transform: translateY(0); opacity: 1; }
        }
    </style>
</head>
<body>
    <div id="app">
        <table id="cooking-checklist">
            <thead>
                <tr class="header-row">
                    <th class="row-number">#</th>
                    <th>Column 1</th>
                    <th class="portion-column">Column 2</th>
                    <th style="text-align: center;">Column 3</th>
                    <th style="text-align: center;">Column 4</th>
                </tr>
            </thead>
            <tbody id="table-body">
                <!-- Table rows will be generated dynamically -->
            </tbody>
        </table>
    </div>

    <script>
        // Function to fetch and parse CSV data from Google Sheets
        function fetchDataFromGoogleSheets() {
            // Original CSV URL from Google Sheets
            const originalCsvUrl = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vSlkqs1NPRzcnn5pL0idFo0u58eDZSExJarqh2NqQexmhSMLYmyahISVleD04TULNebkNoi92XFDVvM/pub?gid=1548051930&single=true&output=csv';
            
            // Use a CORS proxy to handle cross-origin requests
            const corsProxyUrl = 'https://corsproxy.io/?';
            
            // Add cache busting parameter to always fetch fresh data
            const csvUrl = corsProxyUrl + encodeURIComponent(originalCsvUrl + '&cachebust=' + Date.now());
            
            console.log('Fetching data from:', csvUrl);
            
            // Primary fetch attempt using CORS proxy
            fetch(csvUrl)
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok: ' + response.statusText);
                    }
                    return response.text();
                })
                .then(csvText => {
                    processCsvData(csvText);
                })
                .catch(error => {
                    console.error('Error fetching or parsing CSV:', error);
                    console.log('Trying direct fetch as fallback...');
                    
                    // Fallback: try direct fetch (works in some environments)
                    fetch(originalCsvUrl, { mode: 'no-cors' })
                        .then(response => {
                            if (response.type === 'opaque') {
                                // With no-cors, we can't actually read the content
                                console.log('Direct fetch succeeded but content is opaque due to CORS');
                                throw new Error('Cannot read content due to CORS restrictions');
                            }
                            return response.text();
                        })
                        .then(csvText => {
                            console.log('Direct fetch succeeded!');
                            processCsvData(csvText);
                        })
                        .catch(directError => {
                            console.error('Direct fetch also failed:', directError);
                            console.log('Falling back to default empty data');
                            // Initialize with default data if all fetches fail
                            initTable();
                        });
                });
        }
        
        // Helper function to properly parse CSV rows (handles quoted values)
        function parseCSVRow(row) {
            const result = [];
            let insideQuotes = false;
            let currentValue = '';
            
            for (let i = 0; i < row.length; i++) {
                const char = row[i];
                
                if (char === '"') {
                    insideQuotes = !insideQuotes;
                } else if (char === ',' && !insideQuotes) {
                    result.push(currentValue);
                    currentValue = '';
                } else {
                    currentValue += char;
                }
            }
            
            // Add the last value
            result.push(currentValue);
            
            return result;
        }
        
        // Helper function to process CSV text
        function processCsvData(csvText) {
            // Parse CSV to array format
            const rows = csvText.split('\n');
            const parsedData = [];
            
            // Process each row (skip header if present)
            for (let i = 0; i < rows.length; i++) {
                if (!rows[i].trim()) continue; // Skip empty rows
                
                // Parse the CSV row properly (handling quoted values)
                const values = parseCSVRow(rows[i]);
                
                // Skip header row or rows without proper data
                if (isNaN(parseInt(values[1])) && i === 0) continue;
                if (!values[0]) continue; // Skip rows without a dish name
                
                // Parse portions value
                const portions = parseInt(values[1] || '0', 10);
                if (portions === 0) continue; // Skip rows with 0 portions
                
                // Create row in the format: [name, portions, checked1, checked2, url]
                parsedData.push([
                    values[0].trim(),                // Name
                    portions,                        // Portions
                    false,                          // First checkbox (always start unchecked)
                    false,                          // Second checkbox (always start unchecked)
                    values[6] || '#'                // URL from column G (Google Docs link) or default to '#'
                ]);
            }
            
            console.log('Parsed data from CSV:', parsedData);
            
            // Replace the table data with the parsed data
            console.log('Before replacement, tableData length:', tableData.length);
            
            // Clear the existing tableData array and replace with parsed data
            tableData.length = 0; // Clear the array
            parsedData.forEach(row => tableData.push(row)); // Add new data
            
            console.log('After replacement, tableData length:', tableData.length);
            console.log('First few items:', tableData.slice(0, 3));
            
            // Reset position tracking since we have new data
            resetPositionTracking();
            
            // Initialize the table with the new data
            initTable();
        }
        
        // Initialize empty table data array that will be filled from the CSV
        // Format: [name, portions, checked1, checked2, url]
        const tableData = [];



        // Store original positions separately from the JSON data
        const originalPositions = {};
        const rowIds = {};
        
        // Reset position tracking (used when loading new data)
        function resetPositionTracking() {
            // Clear existing position data
            Object.keys(originalPositions).forEach(key => delete originalPositions[key]);
            Object.keys(rowIds).forEach(key => delete rowIds[key]);
            console.log('Position tracking reset');
        }
        
        // Initialize or ensure original positions are tracked
        function initializePositionTracking() {
            // Generate a unique ID for each row based on its name (or other unique property)
            tableData.forEach((rowData, index) => {
                // Use dish name as a unique identifier
                const dishName = rowData[0];
                
                // If this dish doesn't have an ID yet, create one
                if (!rowIds[dishName]) {
                    rowIds[dishName] = Date.now() + index; // Unique ID
                }
                
                // If this dish doesn't have a position yet, store its current position
                if (originalPositions[dishName] === undefined) {
                    originalPositions[dishName] = index;
                }
            });
            
            console.log('Position tracking initialized:', originalPositions);
        }
        
        // Initialize the table
        function initTable() {
            const tableBody = document.getElementById('table-body');
            tableBody.innerHTML = '';
            
            // Make sure position tracking is initialized
            initializePositionTracking();
            
            // Sort the table data to ensure consistent ordering
            sortTableData();
            
            console.log('Current original positions:', originalPositions);

            // Render the sorted table data
            tableData.forEach((rowData, index) => {
                // Create row
                const row = createTableRow(rowData, index);
                
                // Add animation class
                row.classList.add('animated-row');
                
                // Add slide animation for newly moved rows
                if (rowData.isMoving) {
                    if (rowData.moveDirection === 'up') {
                        row.classList.add('slide-up');
                    } else if (rowData.moveDirection === 'down') {
                        row.classList.add('slide-down');
                    }
                    
                    // Clear the moving flag after animation
                    setTimeout(() => {
                        rowData.isMoving = false;
                        rowData.moveDirection = null;
                    }, 500);
                }
                
                tableBody.appendChild(row);
            });
        }

        // Create a table row
        function createTableRow(rowData, index) {
            const [dish, portions, cooked, portioned] = rowData;
            const row = document.createElement('tr');
            
            // Add row number cell
            const rowNumberCell = document.createElement('td');
            rowNumberCell.className = 'row-number';
            rowNumberCell.textContent = index + 1;
            row.appendChild(rowNumberCell);
            
            // Add dish name cell with hyperlink styling
            const dishCell = document.createElement('td');
            if (dish) {
                const dishLink = document.createElement('a');
                dishLink.href = rowData[4] || '#'; // Use URL from data or default to #
                dishLink.textContent = dish;
                dishLink.onclick = (e) => {
                    e.preventDefault();
                    alert('Clicked on: ' + dish);
                };
                dishCell.appendChild(dishLink);
            }
            row.appendChild(dishCell);
            
            // Add portions cell
            const portionsCell = document.createElement('td');
            portionsCell.className = 'portion-column';
            portionsCell.textContent = portions;
            row.appendChild(portionsCell);
            
            // Add cooked checkbox cell
            const cookedCell = document.createElement('td');
            cookedCell.style.textAlign = 'center';
            const cookedCheckbox = document.createElement('input');
            cookedCheckbox.type = 'checkbox';
            cookedCheckbox.checked = cooked;
            cookedCheckbox.addEventListener('change', function() {
                handleCheckboxChange(index, 2, this.checked);
            });
            cookedCell.appendChild(cookedCheckbox);
            row.appendChild(cookedCell);
            
            // Add portioned checkbox cell
            const portionedCell = document.createElement('td');
            portionedCell.style.textAlign = 'center';
            const portionedCheckbox = document.createElement('input');
            portionedCheckbox.type = 'checkbox';
            portionedCheckbox.checked = portioned;
            
            // Disable the portioned checkbox if cooked is not checked
            if (!cooked) {
                portionedCheckbox.disabled = true;
                portionedCheckbox.style.opacity = '0.5';
                portionedCheckbox.style.cursor = 'not-allowed';
            }
            
            portionedCheckbox.addEventListener('change', function() {
                handleCheckboxChange(index, 3, this.checked);
            });
            portionedCell.appendChild(portionedCheckbox);
            row.appendChild(portionedCell);
            
            // Apply green background if cooked checkbox is checked
            if (cooked) {
                row.classList.add('cooked');
            }
            
            // Apply blue background if portioned checkbox is checked
            if (portioned) {
                row.classList.add('portioned');
            }
            
            return row;
        }

        // Handle checkbox change
        function handleCheckboxChange(rowIndex, columnIndex, isChecked) {
            // Get the dish name before updating the data (for logging)
            const dishName = tableData[rowIndex][0];
            console.log(`Checkbox change: ${dishName}, column ${columnIndex}, checked: ${isChecked}`);
            
            // Handle differently based on whether checking or unchecking
            if (isChecked) {
                // CHECKING: Update the data first
                tableData[rowIndex][columnIndex] = isChecked;
                
                // If it's the "portioned" checkbox (column index 3), we don't auto-check the first one
                // This allows portioned-only rows to go to the bottom bucket
                if (columnIndex === 3) {
                    console.log(`Portioned checkbox checked for ${dishName}`);
                }
                
                // If the first checkbox (cooked) is being checked, enable the second checkbox (portioned)
                if (columnIndex === 2) {
                    // Find the row in the table and enable the portioned checkbox
                    const tableBody = document.getElementById('table-body');
                    const row = tableBody.children[rowIndex];
                    if (row) {
                        const portionedCheckbox = row.querySelector('td:nth-child(5) input');
                        if (portionedCheckbox) {
                            portionedCheckbox.disabled = false;
                            portionedCheckbox.style.opacity = '1';
                            portionedCheckbox.style.cursor = 'pointer';
                        }
                    }
                }
                
                // Show checkbox state and color change immediately
                initTable();
                
                // Add a delay before moving the row
                setTimeout(() => {
                    // If it's the "cooked" checkbox (column index 2) and not portioned
                    if (columnIndex === 2 && !tableData[rowIndex][3]) {
                        console.log(`Moving ${dishName} to top (cooked section)`);
                        moveRowToTop(rowIndex);
                    }
                    
                    // If it's the "portioned" checkbox (column index 3)
                    if (columnIndex === 3) {
                        // Check if the first checkbox is also checked
                        if (tableData[rowIndex][2] === true) {
                            // Both checkboxes are checked, so it goes to the top section
                            console.log(`Moving ${dishName} to top (cooked section)`);
                            moveRowToTop(rowIndex);
                        } else {
                            // Only the second checkbox is checked, so it goes to the bottom section
                            console.log(`Moving ${dishName} to bottom (portioned-only section)`);
                            moveRowToBottom(rowIndex);
                        }
                    }
                    
                    // Refresh the table again to show the movement
                    initTable();
                }, 100); // Reduced delay for smoother experience
            } else {
                // UNCHECKING: Handle special cases
                
                // If it's the "cooked" checkbox (column index 2)
                if (columnIndex === 2) {
                    // If the second checkbox is also checked, uncheck it too
                    if (tableData[rowIndex][3] === true) {
                        console.log(`Unchecking portioned checkbox for ${dishName} as well`);
                        tableData[rowIndex][3] = false;
                    }
                    
                    // Update the current checkbox state
                    tableData[rowIndex][columnIndex] = isChecked;
                    
                    console.log(`Moving ${dishName} back to regular section`);
                    // Move back to regular section
                    moveRowToOriginalPosition(rowIndex, false); // false = no animation
                }
                
                // If it's the "portioned" checkbox (column index 3)
                if (columnIndex === 3) {
                    // Update the checkbox state
                    tableData[rowIndex][columnIndex] = isChecked;
                    
                    // Keep the first checkbox checked
                    if (tableData[rowIndex][2] === true) {
                        console.log(`Keeping ${dishName} in cooked section (first checkbox still checked)`);
                        moveRowToTop(rowIndex);
                    }
                }
                
                // Refresh the table immediately
                initTable();
            }
        }

        // Move a row to the top section (cooked rows)
        function moveRowToTop(rowIndex) {
            // Get the row data and dish name for logging
            const rowData = tableData[rowIndex];
            const dishName = rowData[0];
            
            console.log(`Moving ${dishName} to top section (cooked)`);
            
            // Add animation flags
            rowData.isMoving = true;
            rowData.moveDirection = 'up';
            
            // Mark the row as cooked (column index 2)
            rowData[2] = true;
            
            // Apply the bucket sorting system to reorganize the table
            sortTableData();
            
            console.log(`Moved ${dishName} to cooked section`);
        }

        // Move a row to the bottom section (portioned-only)
        function moveRowToBottom(rowIndex) {
            // Get the row data and dish name for logging
            const rowData = tableData[rowIndex];
            const dishName = rowData[0];
            
            console.log(`Moving ${dishName} to bottom section (portioned-only)`);
            
            // Add animation flags
            rowData.isMoving = true;
            rowData.moveDirection = 'down';
            
            // Ensure the row is portioned but not cooked
            rowData[3] = true;  // Mark as portioned (column index 3)
            rowData[2] = false; // Ensure not cooked (column index 2)
            
            // Apply the bucket sorting system to reorganize the table
            sortTableData();
            
            console.log(`Moved ${dishName} to portioned-only section`);
        }
        
        // Sort the table data using a bucket-based approach
        function sortTableData() {
            // Create three separate buckets for different row types
            const cookedBucket = [];
            const regularBucket = [];
            const portionedOnlyBucket = [];
            
            // Distribute rows into appropriate buckets
            for (let i = 0; i < tableData.length; i++) {
                const row = tableData[i];
                const isCooked = row[2] === true;
                const isPortioned = row[3] === true;
                
                // Create a copy of the row to avoid reference issues
                const rowCopy = [...row];
                
                // Preserve animation flags if present
                if (row.isMoving !== undefined) rowCopy.isMoving = row.isMoving;
                if (row.moveDirection !== undefined) rowCopy.moveDirection = row.moveDirection;
                
                if (isCooked) {
                    // All cooked rows go to the top bucket (whether portioned or not)
                    cookedBucket.push(rowCopy);
                } else if (isPortioned) {
                    // Rows that are portioned but not cooked go to the bottom bucket
                    portionedOnlyBucket.push(rowCopy);
                } else {
                    // Regular rows (neither cooked nor portioned) go to the middle bucket
                    regularBucket.push(rowCopy);
                }
            }
            
            // Sort each bucket alphabetically by dish name
            cookedBucket.sort((a, b) => a[0].localeCompare(b[0]));
            regularBucket.sort((a, b) => a[0].localeCompare(b[0]));
            portionedOnlyBucket.sort((a, b) => a[0].localeCompare(b[0]));
            
            // Clear the table data array
            tableData.length = 0;
            
            // Combine the buckets in the desired order
            cookedBucket.forEach(row => tableData.push(row));
            regularBucket.forEach(row => tableData.push(row));
            portionedOnlyBucket.forEach(row => tableData.push(row));
            
            // Log the bucket sizes for debugging
            console.log(`Bucket sizes - Cooked: ${cookedBucket.length}, Regular: ${regularBucket.length}, Portioned-only: ${portionedOnlyBucket.length}`);
        }

        // Move a row back to its original position (regular section)
        function moveRowToOriginalPosition(rowIndex, animate = true) {
            // Get the row data
            const rowData = tableData[rowIndex];
            
            // Get the dish name for logging
            const dishName = rowData[0];
            
            console.log(`Moving ${dishName} back to regular section (unchecked)`);
            
            // Add animation flags only if animation is requested
            if (animate) {
                rowData.isMoving = true;
                rowData.moveDirection = 'down';
            } else {
                // Make sure no animation happens
                rowData.isMoving = false;
                rowData.moveDirection = null;
            }
            
            // Reset the row's state to unchecked for both checkboxes
            rowData[2] = false; // Uncheck cooked
            rowData[3] = false; // Uncheck portioned
            
            // Apply the bucket sorting system to reorganize the table
            sortTableData();
            
            console.log(`Moved ${dishName} to regular section`);
        }

        // Remove duplicate dishes
        function removeDuplicates() {
            const uniqueDishes = new Set();
            const indicesToRemove = [];
            
            tableData.forEach((rowData, index) => {
                const dish = rowData[0];
                if (dish && uniqueDishes.has(dish)) {
                    indicesToRemove.push(index);
                } else if (dish) {
                    uniqueDishes.add(dish);
                }
            });
            
            // Remove duplicates from the end to avoid index shifting
            for (let i = indicesToRemove.length - 1; i >= 0; i--) {
                tableData.splice(indicesToRemove[i], 1);
            }
        }

        // Initialize the table when the page loads
        window.onload = function() {
            // Fetch data from Google Sheets and initialize the table
            fetchDataFromGoogleSheets();
            // Note: initTable() is called inside fetchDataFromGoogleSheets() after data is loaded
        };
    </script>
</body>
</html>
