<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cooking Checklist</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            table-layout: fixed;
        }
        
        th {
            background-color: #5b6abf;
            color: white;
            text-align: left;
            padding: 15px;
            font-size: 20px;
            position: sticky;
            top: 0;
        }
        
        td {
            padding: 15px;
            border-bottom: 1px solid #f0f0f0;
            font-size: 18px;
            height: 40px;
        }
        
        /* Alternating row colors */
        tr:nth-child(odd) {
            background-color: white;
        }
        
        tr:nth-child(even) {
            background-color: #f2f2f2;
        }
        
        /* Green background for rows with first checkbox checked */
        tr.cooked {
            background-color: #00ff9d !important;
        }
        
        /* Blue background for rows with second checkbox checked */
        tr.portioned {
            background-color: #99ccff !important;
        }
        
        /* Checkbox styling */
        input[type="checkbox"] {
            width: 30px;
            height: 30px;
            cursor: pointer;
        }
        
        /* First column (dish name) styling */
        td:first-child a {
            color: #0066cc;
            text-decoration: none;
            font-weight: bold;
            font-size: 18px;
            cursor: pointer;
        }
        
        td:first-child a:hover {
            text-decoration: underline;
        }
        
        /* Row number column */
        .row-number {
            width: 30px;
            text-align: center;
            background-color: #e0e0e0;
            color: #333;
            font-weight: bold;
        }
        
        /* Header row */
        .header-row {
            height: 40px;
        }
        
        /* Portion column */
        .portion-column {
            text-align: right;
            padding-right: 20px;
        }
        
        /* Animation for row movement */
        .animated-row {
            transition: all 0.5s ease-in-out;
        }
        
        /* Animation classes */
        .slide-up {
            animation: slideUp 0.5s ease-in-out;
        }
        
        .slide-down {
            animation: slideDown 0.5s ease-in-out;
        }
        
        @keyframes slideUp {
            from { transform: translateY(50px); opacity: 0.5; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        @keyframes slideDown {
            from { transform: translateY(-50px); opacity: 0.5; }
            to { transform: translateY(0); opacity: 1; }
        }
    </style>
</head>
<body>
    <div id="app">
        <table id="cooking-checklist">
            <thead>
                <tr class="header-row">
                    <th class="row-number">#</th>
                    <th>Column 1</th>
                    <th class="portion-column">Column 2</th>
                    <th style="text-align: center;">Column 3</th>
                    <th style="text-align: center;">Column 4</th>
                </tr>
            </thead>
            <tbody id="table-body">
                <!-- Table rows will be generated dynamically -->
            </tbody>
        </table>
    </div>

    <script>
        // Constants for state management
        const STATE = {
            UNCHECKED: 0,
            COOKED: 1,
            PORTIONED: 2,
            BOTH: 3
        };
        
        const CHECKBOX = {
            COOKED: 2,  // Index in tableData row
            PORTIONED: 3 // Index in tableData row
        };
        
        // State Manager class
        class StateManager {
            constructor() {
                this.stateChangeListeners = [];
            }
            
            // Get the current state of a row
            getRowState(rowData) {
                const isCooked = rowData[CHECKBOX.COOKED] === true;
                const isPortioned = rowData[CHECKBOX.PORTIONED] === true;
                
                if (isCooked && isPortioned) return STATE.BOTH;
                if (isCooked) return STATE.COOKED;
                if (isPortioned) return STATE.PORTIONED;
                return STATE.UNCHECKED;
            }
            
            // Update a row's state
            updateRowState(rowIndex, newState) {
                // Get current row data
                const rowData = tableData[rowIndex];
                if (!rowData) {
                    console.error(`Row ${rowIndex} not found`);
                    return false;
                }
                
                // Update checkboxes based on the new state
                switch(newState) {
                    case STATE.UNCHECKED:
                        rowData[CHECKBOX.COOKED] = false;
                        rowData[CHECKBOX.PORTIONED] = false;
                        break;
                    case STATE.COOKED:
                        rowData[CHECKBOX.COOKED] = true;
                        rowData[CHECKBOX.PORTIONED] = false;
                        break;
                    case STATE.PORTIONED:
                        rowData[CHECKBOX.COOKED] = false;
                        rowData[CHECKBOX.PORTIONED] = true;
                        break;
                    case STATE.BOTH:
                        rowData[CHECKBOX.COOKED] = true;
                        rowData[CHECKBOX.PORTIONED] = true;
                        break;
                    default:
                        console.error(`Invalid state: ${newState}`);
                        return false;
                }
                
                // Notify listeners of state change
                this.notifyStateChange(rowIndex, newState);
                return true;
            }
            
            // Update state based on checkbox change
            handleCheckboxChange(rowIndex, checkboxIndex, isChecked) {
                const rowData = tableData[rowIndex];
                if (!rowData) {
                    console.error(`Row ${rowIndex} not found`);
                    return false;
                }
                
                // Get current state
                const currentState = this.getRowState(rowData);
                let newState;
                
                // Determine new state based on which checkbox changed
                if (checkboxIndex === CHECKBOX.COOKED) {
                    if (isChecked) {
                        newState = currentState === STATE.PORTIONED ? STATE.BOTH : STATE.COOKED;
                    } else {
                        newState = currentState === STATE.BOTH ? STATE.PORTIONED : STATE.UNCHECKED;
                    }
                } else if (checkboxIndex === CHECKBOX.PORTIONED) {
                    if (isChecked) {
                        newState = currentState === STATE.COOKED ? STATE.BOTH : STATE.PORTIONED;
                    } else {
                        newState = currentState === STATE.BOTH ? STATE.COOKED : STATE.UNCHECKED;
                    }
                } else {
                    console.error(`Invalid checkbox index: ${checkboxIndex}`);
                    return false;
                }
                
                // Update to new state
                return this.updateRowState(rowIndex, newState);
            }
            
            // Add a state change listener
            addStateChangeListener(listener) {
                if (typeof listener === 'function') {
                    this.stateChangeListeners.push(listener);
                }
            }
            
            // Notify all listeners of a state change
            notifyStateChange(rowIndex, newState) {
                for (const listener of this.stateChangeListeners) {
                    listener(rowIndex, newState);
                }
            }
        }
        
        // Create global state manager
        const stateManager = new StateManager();
        
        // Position Manager class to handle row positioning
        class PositionManager {
            constructor() {
                // Register as a state change listener
                stateManager.addStateChangeListener(this.handleStateChange.bind(this));
            }
            
            // Handle state changes
            handleStateChange(rowIndex, newState) {
                console.log(`State changed for row ${rowIndex} to ${newState}`);
                
                // Determine the new position based on state
                switch(newState) {
                    case STATE.UNCHECKED:
                        this.moveToOriginalPosition(rowIndex);
                        break;
                    case STATE.COOKED:
                        this.moveToTop(rowIndex);
                        break;
                    case STATE.PORTIONED:
                        this.moveToOriginalPosition(rowIndex);
                        break;
                    case STATE.BOTH:
                        this.moveToBottom(rowIndex);
                        break;
                }
                
                // Refresh the table to show the changes
                initTable();
            }
            
            // Move a row to the top (below other cooked rows)
            moveToTop(rowIndex) {
                // Get the row data
                const rowData = tableData[rowIndex];
                if (!rowData) return;
                
                // Add animation flags
                rowData.isMoving = true;
                rowData.moveDirection = 'up';
                
                // Remove the row from its current position
                tableData.splice(rowIndex, 1);
                
                // Find the position of the last cooked row
                let insertPosition = 0; // Default to top position
                
                // Loop through the data to find the last cooked row
                for (let i = 0; i < tableData.length; i++) {
                    if (stateManager.getRowState(tableData[i]) === STATE.COOKED) {
                        insertPosition = i + 1; // Insert after this row
                    }
                }
                
                // Insert the row at the determined position
                tableData.splice(insertPosition, 0, rowData);
                
                console.log(`Moved row to position ${insertPosition} (below other cooked rows)`);
            }
            
            // Move a row to the bottom of the table
            moveToBottom(rowIndex) {
                // Get the row data
                const rowData = tableData[rowIndex];
                if (!rowData) return;
                
                // Add animation flags
                rowData.isMoving = true;
                rowData.moveDirection = 'down';
                
                // Remove the row from its current position
                tableData.splice(rowIndex, 1);
                
                // Add it to the end of the array
                tableData.push(rowData);
                
                console.log(`Moved row to bottom`);
            }
            
            // Move a row back to its original position
            moveToOriginalPosition(rowIndex, animate = true) {
                // Get the row data
                const rowData = tableData[rowIndex];
                if (!rowData) return;
                
                // Get the dish name to look up the original position
                const dishName = rowData[0];
                
                // Get the original position from our mapping
                const originalIndex = originalPositions[dishName];
                
                console.log(`Moving row ${rowIndex} (${dishName}) back to original position ${originalIndex}`);
                
                // Add animation flags only if animation is requested
                if (animate) {
                    rowData.isMoving = true;
                    rowData.moveDirection = 'down';
                } else {
                    // Make sure no animation happens
                    rowData.isMoving = false;
                    rowData.moveDirection = null;
                }
                
                // Remove the row from its current position
                tableData.splice(rowIndex, 1);
                
                // Make sure we don't insert beyond the array bounds
                const insertPosition = Math.min(originalIndex, tableData.length);
                
                // Insert it at the original position
                tableData.splice(insertPosition, 0, rowData);
                
                console.log(`Moved row back to position ${insertPosition}`);
            }
        }
        
        // Create global position manager
        const positionManager = new PositionManager();
        
        // Function to fetch and parse CSV data from Google Sheets
        function fetchDataFromGoogleSheets() {
            // Original CSV URL
            const originalCsvUrl = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vQM10ZHnytdBTAM5dR4ZU0koZA99GDoeXh-I8LnvFHx6dgzVBpuupAuWvOElWoarHYt3LrQVG5r9L3L/pub?gid=1548051930&single=true&output=csv';
            
            // Try a different CORS proxy
            const corsProxyUrl = 'https://api.allorigins.win/raw?url=';
            const csvUrl = corsProxyUrl + encodeURIComponent(originalCsvUrl);
            
            console.log('Fetching data from:', csvUrl);
            
            fetch(csvUrl)
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok: ' + response.statusText);
                    }
                    return response.text();
                })
                .then(csvText => {
                    processCsvData(csvText);
                })
                .catch(error => {
                    console.error('Error fetching or parsing CSV:', error);
                    console.log('Trying direct fetch as fallback...');
                    
                    // As a fallback, try direct fetch (works in some environments)
                    fetch(originalCsvUrl, { mode: 'no-cors' })
                        .then(response => {
                            if (response.type === 'opaque') {
                                // With no-cors, we can't actually read the content
                                console.log('Direct fetch succeeded but content is opaque due to CORS');
                                throw new Error('Cannot read content due to CORS restrictions');
                            }
                            return response.text();
                        })
                        .then(csvText => {
                            // Process CSV text as before
                            console.log('Direct fetch succeeded!');
                            processCsvData(csvText);
                        })
                        .catch(directError => {
                            console.error('Direct fetch also failed:', directError);
                            console.log('Falling back to default empty data');
                            // Initialize with default data if all fetches fail
                            initTable();
                        });
                });
        }
        
        // Helper function to properly parse CSV rows (handles quoted values)
        function parseCSVRow(row) {
            const result = [];
            let insideQuotes = false;
            let currentValue = '';
            
            for (let i = 0; i < row.length; i++) {
                const char = row[i];
                
                if (char === '"') {
                    insideQuotes = !insideQuotes;
                } else if (char === ',' && !insideQuotes) {
                    result.push(currentValue);
                    currentValue = '';
                } else {
                    currentValue += char;
                }
            }
            
            // Add the last value
            result.push(currentValue);
            
            return result;
        }
        
        // Helper function to process CSV text
        function processCsvData(csvText) {
            // Parse CSV to array format
            const rows = csvText.split('\n');
            const parsedData = [];
            
            // Process each row (skip header if present)
            for (let i = 0; i < rows.length; i++) {
                if (!rows[i].trim()) continue; // Skip empty rows
                
                // Parse the CSV row properly (handling quoted values)
                const values = parseCSVRow(rows[i]);
                
                // Skip header row or rows without proper data
                if (isNaN(parseInt(values[1])) && i === 0) continue;
                if (!values[0]) continue; // Skip rows without a dish name
                
                // Create row in the format: [name, portions, checked1, checked2, url]
                parsedData.push([
                    values[0].trim(),                // Name
                    parseInt(values[1] || '0', 10), // Portions
                    false,                          // First checkbox (always start unchecked)
                    false,                          // Second checkbox (always start unchecked)
                    values[2] || '#'                // URL (or default to '#')
                ]);
            }
            
            console.log('Parsed data from CSV:', parsedData);
            
            // Replace the table data with the parsed data
            console.log('Before replacement, tableData length:', tableData.length);
            
            // Clear the existing tableData array and replace with parsed data
            tableData.length = 0; // Clear the array
            parsedData.forEach(row => tableData.push(row)); // Add new data
            
            console.log('After replacement, tableData length:', tableData.length);
            console.log('First few items:', tableData.slice(0, 3));
            
            // Reset position tracking since we have new data
            resetPositionTracking();
            
            // Initialize the table with the new data
            initTable();
        }
        
        // Initialize empty table data array that will be filled from the CSV
        // Format: [name, portions, checked1, checked2, url]
        const tableData = [];



        // Store original positions separately from the JSON data
        const originalPositions = {};
        const rowIds = {};
        
        // Reset position tracking (used when loading new data)
        function resetPositionTracking() {
            // Clear existing position data
            Object.keys(originalPositions).forEach(key => delete originalPositions[key]);
            Object.keys(rowIds).forEach(key => delete rowIds[key]);
            console.log('Position tracking reset');
        }
        
        // Initialize or ensure original positions are tracked
        function initializePositionTracking() {
            // Generate a unique ID for each row based on its name (or other unique property)
            tableData.forEach((rowData, index) => {
                // Use dish name as a unique identifier
                const dishName = rowData[0];
                
                // If this dish doesn't have an ID yet, create one
                if (!rowIds[dishName]) {
                    rowIds[dishName] = Date.now() + index; // Unique ID
                }
                
                // If this dish doesn't have a position yet, store its current position
                if (originalPositions[dishName] === undefined) {
                    originalPositions[dishName] = index;
                }
            });
            
            console.log('Position tracking initialized:', originalPositions);
        }
        
        // Initialize the table
        function initTable() {
            const tableBody = document.getElementById('table-body');
            tableBody.innerHTML = '';
            
            // Make sure position tracking is initialized
            initializePositionTracking();
            
            console.log('Current original positions:', originalPositions);

            tableData.forEach((rowData, index) => {
                // Create row
                const row = createTableRow(rowData, index);
                
                // Add animation class
                row.classList.add('animated-row');
                
                // Add slide animation for newly moved rows
                if (rowData.isMoving) {
                    if (rowData.moveDirection === 'up') {
                        row.classList.add('slide-up');
                    } else if (rowData.moveDirection === 'down') {
                        row.classList.add('slide-down');
                    }
                    
                    // Clear the moving flag after animation
                    setTimeout(() => {
                        rowData.isMoving = false;
                        rowData.moveDirection = null;
                    }, 500);
                }
                
                tableBody.appendChild(row);
            });
        }

        // Create a table row
        function createTableRow(rowData, index) {
            const [dish, portions, cooked, portioned] = rowData;
            const row = document.createElement('tr');
            
            // Add row number cell
            const rowNumberCell = document.createElement('td');
            rowNumberCell.className = 'row-number';
            rowNumberCell.textContent = index + 1;
            row.appendChild(rowNumberCell);
            
            // Add dish name cell with hyperlink styling
            const dishCell = document.createElement('td');
            if (dish) {
                const dishLink = document.createElement('a');
                dishLink.href = rowData[4] || '#'; // Use URL from data or default to #
                dishLink.textContent = dish;
                dishLink.onclick = (e) => {
                    e.preventDefault();
                    alert('Clicked on: ' + dish);
                };
                dishCell.appendChild(dishLink);
            }
            row.appendChild(dishCell);
            
            // Add portions cell
            const portionsCell = document.createElement('td');
            portionsCell.className = 'portion-column';
            portionsCell.textContent = portions;
            row.appendChild(portionsCell);
            
            // Add cooked checkbox cell
            const cookedCell = document.createElement('td');
            cookedCell.style.textAlign = 'center';
            const cookedCheckbox = document.createElement('input');
            cookedCheckbox.type = 'checkbox';
            cookedCheckbox.checked = cooked;
            cookedCheckbox.addEventListener('change', function() {
                handleCheckboxChange(index, 2, this.checked);
            });
            cookedCell.appendChild(cookedCheckbox);
            row.appendChild(cookedCell);
            
            // Add portioned checkbox cell
            const portionedCell = document.createElement('td');
            portionedCell.style.textAlign = 'center';
            const portionedCheckbox = document.createElement('input');
            portionedCheckbox.type = 'checkbox';
            portionedCheckbox.checked = portioned;
            portionedCheckbox.addEventListener('change', function() {
                handleCheckboxChange(index, 3, this.checked);
            });
            portionedCell.appendChild(portionedCheckbox);
            row.appendChild(portionedCell);
            
            // Apply green background if cooked checkbox is checked
            if (cooked) {
                row.classList.add('cooked');
            }
            
            // Apply blue background if portioned checkbox is checked
            if (portioned) {
                row.classList.add('portioned');
            }
            
            return row;
        }

        // Handle checkbox change
        function handleCheckboxChange(rowIndex, columnIndex, isChecked) {
            // Get the dish name before updating the data (for logging)
            const dishName = tableData[rowIndex][0];
            console.log(`Checkbox change: ${dishName}, column ${columnIndex}, checked: ${isChecked}`);
            console.log(`Original position for ${dishName}: ${originalPositions[dishName]}`);
            
            // Handle differently based on whether checking or unchecking
            if (isChecked) {
                // CHECKING: Update the data first
                tableData[rowIndex][columnIndex] = isChecked;
                
                // Show checkbox state and color change immediately
                initTable();
                
                // Add a delay before moving the row
                setTimeout(() => {
                    // If it's the "cooked" checkbox (column index 2)
                    if (columnIndex === 2) {
                        console.log(`Moving ${dishName} to top`);
                        // Move to top
                        moveRowToTop(rowIndex);
                    }
                    
                    // If it's the "portioned" checkbox (column index 3)
                    if (columnIndex === 3) {
                        console.log(`Moving ${dishName} to bottom`);
                        // Move to bottom
                        moveRowToBottom(rowIndex);
                    }
                    
                    // Refresh the table again to show the movement
                    initTable();
                }, 500); // 500ms delay before moving
            } else {
                // UNCHECKING: Handle special cases
                
                // If it's the "cooked" checkbox (column index 2)
                if (columnIndex === 2) {
                    // If the second checkbox is also checked, uncheck it too
                    if (tableData[rowIndex][3] === true) {
                        console.log(`Unchecking portioned checkbox for ${dishName} as well`);
                        tableData[rowIndex][3] = false;
                    }
                    
                    // Update the current checkbox state
                    tableData[rowIndex][columnIndex] = isChecked;
                    
                    console.log(`Moving ${dishName} back to original position ${originalPositions[dishName]}`);
                    // Move back to original position immediately
                    moveRowToOriginalPosition(rowIndex, false); // false = no animation
                }
                
                // If it's the "portioned" checkbox (column index 3)
                if (columnIndex === 3) {
                    // Update the checkbox state
                    tableData[rowIndex][columnIndex] = isChecked;
                    
                    // If the first checkbox is still checked, move to top instead of original position
                    if (tableData[rowIndex][2] === true) {
                        console.log(`Moving ${dishName} to top (below other checked rows)`);
                        moveRowToTop(rowIndex);
                    } else {
                        // If first checkbox is not checked, move to original position
                        console.log(`Moving ${dishName} back to original position ${originalPositions[dishName]}`);
                        moveRowToOriginalPosition(rowIndex, false);
                    }
                }
                
                // Refresh the table immediately
                initTable();
            }
        }

        // Move a row below other checked rows
        function moveRowToTop(rowIndex) {
            // Get the row data
            const rowData = tableData[rowIndex];
            
            // Add animation flags
            rowData.isMoving = true;
            rowData.moveDirection = 'up';
            
            // Remove the row from its current position
            tableData.splice(rowIndex, 1);
            
            // Find the position of the last checked row
            let insertPosition = 0; // Default to top position
            
            // Loop through the data to find the last checked row
            for (let i = 0; i < tableData.length; i++) {
                if (tableData[i][2] === true) { // If the row is checked (column 3)
                    insertPosition = i + 1; // Insert after this row
                }
            }
            
            // Insert the row at the determined position
            tableData.splice(insertPosition, 0, rowData);
            
            console.log(`Moved row to position ${insertPosition} (below other checked rows)`);
        }

        // Move a row to the bottom of the table
        function moveRowToBottom(rowIndex) {
            // Get the row data
            const rowData = tableData[rowIndex];
            
            // Add animation flags
            rowData.isMoving = true;
            rowData.moveDirection = 'down';
            
            // Remove the row from its current position
            tableData.splice(rowIndex, 1);
            
            // Add it to the end of the array
            tableData.push(rowData);
        }

        // Move a row back to its original position
        function moveRowToOriginalPosition(rowIndex, animate = true) {
            // Get the row data
            const rowData = tableData[rowIndex];
            
            // Get the dish name to look up the original position
            const dishName = rowData[0];
            
            // Get the original position from our mapping
            const originalIndex = originalPositions[dishName];
            
            console.log(`Moving row ${rowIndex} (${dishName}) back to original position ${originalIndex}`);
            
            // Add animation flags only if animation is requested
            if (animate) {
                rowData.isMoving = true;
                rowData.moveDirection = 'down';
            } else {
                // Make sure no animation happens
                rowData.isMoving = false;
                rowData.moveDirection = null;
            }
            
            // Remove the row from its current position
            tableData.splice(rowIndex, 1);
            
            // Make sure we don't insert beyond the array bounds
            const insertPosition = Math.min(originalIndex, tableData.length);
            
            // Insert it at the original position
            tableData.splice(insertPosition, 0, rowData);
            
            console.log(`Moved row back to position ${insertPosition}`);
        }

        // Remove duplicate dishes
        function removeDuplicates() {
            const uniqueDishes = new Set();
            const indicesToRemove = [];
            
            tableData.forEach((rowData, index) => {
                const dish = rowData[0];
                if (dish && uniqueDishes.has(dish)) {
                    indicesToRemove.push(index);
                } else if (dish) {
                    uniqueDishes.add(dish);
                }
            });
            
            // Remove duplicates from the end to avoid index shifting
            for (let i = indicesToRemove.length - 1; i >= 0; i--) {
                tableData.splice(indicesToRemove[i], 1);
            }
        }

        // Initialize the table when the page loads
        window.onload = function() {
            // Fetch data from Google Sheets and initialize the table
            fetchDataFromGoogleSheets();
            // Note: initTable() is called inside fetchDataFromGoogleSheets() after data is loaded
        };
    </script>
</body>
</html>
